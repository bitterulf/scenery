<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>
    </head>
    <body>
        <script>
            const EasingFunctions = {
                // no easing, no acceleration
                linear: function (t) { return t },
                // accelerating from zero velocity
                easeInQuad: function (t) { return t*t },
                // decelerating to zero velocity
                easeOutQuad: function (t) { return t*(2-t) },
                // acceleration until halfway, then deceleration
                easeInOutQuad: function (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t },
                // accelerating from zero velocity
                easeInCubic: function (t) { return t*t*t },
                // decelerating to zero velocity
                easeOutCubic: function (t) { return (--t)*t*t+1 },
                // acceleration until halfway, then deceleration
                easeInOutCubic: function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 },
                // accelerating from zero velocity
                easeInQuart: function (t) { return t*t*t*t },
                // decelerating to zero velocity
                easeOutQuart: function (t) { return 1-(--t)*t*t*t },
                // acceleration until halfway, then deceleration
                easeInOutQuart: function (t) { return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t },
                // accelerating from zero velocity
                easeInQuint: function (t) { return t*t*t*t*t },
                // decelerating to zero velocity
                easeOutQuint: function (t) { return 1+(--t)*t*t*t*t },
                // acceleration until halfway, then deceleration
                easeInOutQuint: function (t) { return t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }
            };

            const getInterpolationIndexes = function(keyframes, key) {
                let firstIndex = 0;
                keyframes.forEach(function(keyframe, index) {
                    if (keyframe.key <= key) {
                        firstIndex = index;
                    }
                });

                if (firstIndex == keyframes.length - 1) {
                    return [firstIndex, firstIndex];
                }
                else {
                    return [firstIndex, firstIndex + 1];
                }
            };

            const getInterpolationState = function(keyframes, key) {
                const indexes = getInterpolationIndexes(keyframes, key);
                const startFrame = keyframes[indexes[0]];
                const goalFrame = keyframes[indexes[1]];
                const totalTime = goalFrame.key - startFrame.key;
                if (totalTime == 0) {
                    return {
                        x: startFrame.x,
                        y: startFrame.y,
                        color: startFrame.color,
                        alpha: startFrame.alpha
                    }
                }

                const currentTime = key - startFrame.key;
                const percent = currentTime / totalTime;

                const factor = EasingFunctions.easeInOutQuint(percent);

                const color = [
                    (goalFrame.color[0] - startFrame.color[0]) * factor + startFrame.color[0],
                    (goalFrame.color[1] - startFrame.color[1]) * factor + startFrame.color[1],
                    (goalFrame.color[2] - startFrame.color[2]) * factor + startFrame.color[2]
                ];

                return {
                    x: (goalFrame.x - startFrame.x) * factor + startFrame.x,
                    y: (goalFrame.y - startFrame.y) * factor + startFrame.y,
                    color: color,
                    alpha: (goalFrame.alpha - startFrame.alpha) * factor + startFrame.alpha,
                }
            }

            const timelineSprite = function(sprite, keyframes) {
                this.sprite = sprite;
                this.keyframes = keyframes;
            };

            timelineSprite.prototype.updateTime = function(time) {
                const state = getInterpolationState(this.keyframes, time);

                this.sprite.x = state.x;
                this.sprite.y = state.y;
                this.sprite.tint = PIXI.utils.rgb2hex(state.color);
                this.sprite.alpha = state.alpha;
            };

            const createBoard = function() {
                const sprite = new PIXI.Sprite(
                    PIXI.loader.resources.board.texture
                );

                sprite.x = 128;
                sprite.y = 128;
                sprite.width = 86;
                sprite.height = 67;
                sprite.scale.x = 3;
                sprite.scale.y = 3;
                sprite.rotation = 0.0;
                sprite.anchor.x = 0.5;
                sprite.anchor.y = 0.5;

                sprite.interactive = true;
                sprite.buttonMode = true;

                sprite.on('pointerup', function() {
                });

                return sprite;
            };

            let globalTime = 0;

            PIXI.loader
                .add("board", 'front.png')
                .load(function() {
                    console.log(PIXI.utils.rgb2hex([255, 0, 255]));

                    const keyframes = [
                        {key: 0, x: 0, y: 0, alpha: 1, color: [1, 1, 1]},
                        {key: 0.5, x: 100, y: 0, alpha: 1, color: [1, 0, 0]},
                        {key: 1, x: 0, y: 100, alpha: 0, color: [0, 0, 0]}
                    ];

                    const renderer = PIXI.autoDetectRenderer(
                        256, 256,
                        {antialias: false, transparent: false, resolution: 1}
                    );

                    renderer.view.style.border = "1px dashed black";

                    renderer.backboardColor = 0x061639;

                    renderer.autoResize = true;
                    renderer.resize(512, 512);

                    document.body.appendChild(renderer.view);
                    const stage = new PIXI.Container();

                    globalTime = 0;

                    const board = createBoard();

                    stage.addChild(board);

                    const timelineSprites = [
                        new timelineSprite(board, keyframes)
                    ];

                    function gameLoop() {
                        requestAnimationFrame(gameLoop);

                        renderer.render(stage);
                    }

                    gameLoop();

                    window.setInterval(function() {
                        globalTime += 0.01;
                        if (globalTime > 1) {
                            globalTime -= 1;
                        }

                        timelineSprites.forEach(function(timelineSprite) {
                            timelineSprite.updateTime(globalTime)
                        });

                    }, 1000 / 30);
                });
        </script>
    </body>
</html>
