<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>
    </head>
    <body>
        <script>
            const EasingFunctions = {
                // no easing, no acceleration
                linear: function (t) { return t },
                // accelerating from zero velocity
                easeInQuad: function (t) { return t*t },
                // decelerating to zero velocity
                easeOutQuad: function (t) { return t*(2-t) },
                // acceleration until halfway, then deceleration
                easeInOutQuad: function (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t },
                // accelerating from zero velocity
                easeInCubic: function (t) { return t*t*t },
                // decelerating to zero velocity
                easeOutCubic: function (t) { return (--t)*t*t+1 },
                // acceleration until halfway, then deceleration
                easeInOutCubic: function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 },
                // accelerating from zero velocity
                easeInQuart: function (t) { return t*t*t*t },
                // decelerating to zero velocity
                easeOutQuart: function (t) { return 1-(--t)*t*t*t },
                // acceleration until halfway, then deceleration
                easeInOutQuart: function (t) { return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t },
                // accelerating from zero velocity
                easeInQuint: function (t) { return t*t*t*t*t },
                // decelerating to zero velocity
                easeOutQuint: function (t) { return 1+(--t)*t*t*t*t },
                // acceleration until halfway, then deceleration
                easeInOutQuint: function (t) { return t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }
            };

            const getInterpolationIndexes = function(keyframes, key) {
                let firstIndex = 0;
                keyframes.forEach(function(keyframe, index) {
                    if (keyframe.key <= key) {
                        firstIndex = index;
                    }
                });

                if (firstIndex == keyframes.length - 1) {
                    return [firstIndex, firstIndex];
                }
                else {
                    return [firstIndex, firstIndex + 1];
                }
            };

            const getInterpolationState = function(keyframes, key) {
                const indexes = getInterpolationIndexes(keyframes, key);
                const startFrame = keyframes[indexes[0]];
                const goalFrame = keyframes[indexes[1]];
                const totalTime = goalFrame.key - startFrame.key;
                if (totalTime == 0) {
                    return {
                        x: startFrame.x,
                        y: startFrame.y,
                        color: startFrame.color,
                        alpha: startFrame.alpha
                    }
                }

                const currentTime = key - startFrame.key;
                const percent = currentTime / totalTime;

                const factor = EasingFunctions.easeInOutQuint(percent);

                const color = [
                    (goalFrame.color[0] - startFrame.color[0]) * factor + startFrame.color[0],
                    (goalFrame.color[1] - startFrame.color[1]) * factor + startFrame.color[1],
                    (goalFrame.color[2] - startFrame.color[2]) * factor + startFrame.color[2]
                ];

                return {
                    x: (goalFrame.x - startFrame.x) * factor + startFrame.x,
                    y: (goalFrame.y - startFrame.y) * factor + startFrame.y,
                    color: color,
                    alpha: (goalFrame.alpha - startFrame.alpha) * factor + startFrame.alpha,
                }
            }

            const timelineSprite = function(sprite, keyframes) {
                this.sprite = sprite;
                this.keyframes = keyframes;
            };

            timelineSprite.prototype.updateTime = function(time) {
                const state = getInterpolationState(this.keyframes, time);

                this.sprite.x = state.x;
                this.sprite.y = state.y;
                this.sprite.tint = PIXI.utils.rgb2hex(state.color);
                this.sprite.alpha = state.alpha;
            };

            const Actor = function(actions, id, image, time, x, y, status) {

                this.id = id;
                this.image = image;
                this.position = {x: x, y: y};
                this.status = status;
                this.time = time;
                this.actions = actions;
                this.data = {};

                this.addAction();
            };

            Actor.prototype.applyPositionChange = function(positionChange) {
                if (positionChange) {
                    if (positionChange.type == 'moveBy') {
                        this.position.x += positionChange.x;
                        this.position.y += positionChange.y;
                    }
                    else if (positionChange.type == 'moveTo') {
                        this.position.x = positionChange.x;
                        this.position.y = positionChange.y;
                    }
                }
            };

            Actor.prototype.applyTimeChange = function(timeChange) {
                if (timeChange) {
                    if (timeChange.type == 'changeTimeBy') {
                        this.time += timeChange.time;
                    }
                    else if (timeChange.type == 'changeTimeTo') {
                        this.time = timeChange.time;
                    }
                }
            };

            Actor.prototype.addAction = function() {
                this.actions.push({
                    id: this.id,
                    image: this.image,
                    time: this.time,
                    x: this.position.x,
                    y: this.position.y,
                    status: this.status
                });
            };

            Actor.prototype.position = function() {
                this.x = x;
                this.y = y;

                return this;
            };

            Actor.prototype.attacking = function(positionChange, timeChange) {
                this.applyPositionChange(positionChange);
                this.applyTimeChange(timeChange);
                this.status = 'attacking';
                this.addAction();

                return this;
            };

            Actor.prototype.walking = function(positionChange, timeChange) {
                this.applyPositionChange(positionChange);
                this.applyTimeChange(timeChange);
                this.status = 'walking';
                this.addAction();

                return this;
            };

            Actor.prototype.idle = function(timeChange) {
                this.applyTimeChange(timeChange);
                this.status = 'idle';
                this.addAction();

                return this;
            };

            Actor.prototype.hurt = function(positionChange, timeChange) {
                this.applyPositionChange(positionChange);
                this.applyTimeChange(timeChange);
                this.status = 'hurt';
                this.addAction();

                return this;
            };

            Actor.prototype.dead = function(positionChange, timeChange) {
                this.applyPositionChange(positionChange);
                this.applyTimeChange(timeChange);
                this.status = 'dead';
                this.addAction();

                return this;
            };

            const MoveTo = function(x, y) {
                return {
                    x: x,
                    y: y,
                    type: 'moveTo'
                };
            };

            const MoveBy = function(x, y) {
                return {
                    x: x,
                    y: y,
                    type: 'moveBy'
                };
            };

            const ChangeTimeBy = function(time) {
                return {
                    time: time,
                    type: 'changeTimeBy'
                };
            };

            const ChangeTimeTo = function(time) {
                return {
                    time: time,
                    type: 'changeTimeTo'
                };
            };

            const MoveTowards = function(actor) {
                return {
                    x: actor.position.x,
                    y: actor.position.y,
                    type: 'moveTo'
                };
            };

            const RandomTime = function(base, randomized) {
                return base + Math.round(randomized * Math.random());
            };

            const syncActors = function(actors) {
                let maxTime = 0;
                actors.forEach(function(actor) {
                    if (actor.time > maxTime) {
                        maxTime = actor.time
                    }
                });

                actors.forEach(function(actor) {
                    actor.idle(ChangeTimeTo(maxTime + 10));
                });
            };

            const createActions = function() {
                const actions = [];

                const defenders = [];
                for (var d = 0; d < 10; d++) {
                    const defender = new Actor(actions, 'def'+d, 'point.png', 0, 300, 20 + (d * 20), 'idle');
                    if (Math.random() > 0.5) {
                        defender.data.attacked = true;
                    }
                    defenders.push(defender);
                }

                const attackers = [];
                for (var a = 0; a < 10; a++) {
                    const defender = new Actor(actions, 'at'+a, 'point.png', 0, -20, 20 + (a * 20), 'idle');
                    attackers.push(defender);
                }

                attackers.forEach(function(attacker, a) {
                    attacker.walking(MoveTo(100, 20 + (a * 20)), ChangeTimeBy(200));
                });

                syncActors(attackers);

                attackers.forEach(function(attacker, a) {
                    attacker.walking(MoveBy(50, 0), ChangeTimeBy(RandomTime(50, 150)));
                });

                syncActors(attackers);

                attackers.forEach(function(attacker, a) {
                    attacker.attacking(MoveBy(50, 0), ChangeTimeBy(RandomTime(20, 40)));
                });

                return actions;
            };

            const createSceneDataFromActions = function(actions) {
                const sprites = {};

                const states = {
                    attacking: {
                        alpha: 1,
                        color: [1, 1, 1]
                    },
                    walking: {
                        alpha: 1,
                        color: [0.5, 0.5, 1]
                    },
                    idle: {
                        alpha: 1,
                        color: [1, 1, 1]
                    },
                    hurt: {
                        alpha: 1,
                        color: [1, 0, 0]
                    },
                    dead: {
                        alpha: 0.5,
                        color: [0.5, 0.5, 0.5]
                    }
                };

                actions.forEach(function(action) {
                    if (!sprites[action.id]) {
                        sprites[action.id] = [];
                    }

                    sprites[action.id].push(action);
                });

                let result = [];

                Object.keys(sprites).forEach(function(id) {
                    const spriteActions = sprites[id].sort(function(a, b) {
                        return a.time > b.time
                    });

                    const images = spriteActions.map(function(spriteAction) {
                        return spriteAction.image;
                    }).filter(function(image) { return image; });

                    result.push({
                        name: id,
                        image: images[0],
                        scale: 1,
                        keyframes: spriteActions.map(function(spriteAction) {
                            console.log('SPC', spriteAction);
                            const state = states[spriteAction.status];
                            return {
                                key: spriteAction.time,
                                x: spriteAction.x,
                                y: spriteAction.y,
                                alpha: state.alpha,
                                color: state.color
                            };
                        })
                    });
                });

                let maxTime = 0;

                result.forEach(function(entry) {
                    entry.keyframes.forEach(function(keyframe) {
                        if (keyframe.key > maxTime) {
                            maxTime = keyframe.key;
                        }
                    });
                });

                result = result.map(function(entry) {
                    entry.keyframes = entry.keyframes.map(function(keyframe) {
                        keyframe.key = keyframe.key / maxTime;

                        return keyframe;
                    });

                    if (entry.keyframes[0].key != 0) {
                        entry.keyframes.unshift(JSON.parse(JSON.stringify(entry.keyframes[0])));
                        entry.keyframes[0].key = 0;
                    }

                    return entry;
                });

                return result;
            }

            console.log(createSceneDataFromActions(createActions()));

            let globalTime = 0;

            const sceneData = createSceneDataFromActions(createActions());

        	function loadStuff(sceneData) {
                let loader = PIXI.loader;
                sceneData.forEach(function(entry) {
                    loader = loader.add(entry.name, entry.image);
                });

                return loader;
            }

            const createSpriteFromEntry = function(entry) {
                const sprite = new PIXI.Sprite(
                    PIXI.loader.resources[entry.name].texture
                );

                sprite.scale.x = entry.scale;
                sprite.scale.y = entry.scale;
                sprite.rotation = 0.0;
                sprite.anchor.x = 0.5;
                sprite.anchor.y = 0.5;

                sprite.interactive = true;
                sprite.buttonMode = true;

                sprite.on('pointerup', function() {});

                return sprite;
            };

            const createRenderer = function() {
                const renderer = PIXI.autoDetectRenderer(
                    256, 256,
                    {antialias: false, transparent: false, resolution: 1}
                );

                renderer.view.style.border = "1px dashed black";
                renderer.backboardColor = 0x061639;
                renderer.autoResize = true;
                renderer.resize(512, 512);

                document.body.appendChild(renderer.view);

                return renderer;
            };

            const setupLoop = function(renderer, stage) {
                function gameLoop() {
                    requestAnimationFrame(gameLoop);

                    renderer.render(stage);
                }

                gameLoop();
            };

            const setupTimer = function(timelineSprites) {
                globalTime = 0;

                window.setInterval(function() {
                    globalTime += 0.01;
                    if (globalTime > 1) {
                        globalTime -= 1;
                    }

                    timelineSprites.forEach(function(timelineSprite) {
                        timelineSprite.updateTime(globalTime)
                    });

                }, 1000 / 30);
            };

            const sceneData2timelineSprites = function(sceneData) {
                const timelineSprites = [];

                sceneData.forEach(function(entry) {
                    const sprite = createSpriteFromEntry(entry);

                    // stage.addChild(sprite);

                    timelineSprites.push(new timelineSprite(sprite, entry.keyframes));
                });

                return timelineSprites;
            };

            const attachSpritesToStage = function(timelineSprites, stage) {
                timelineSprites.forEach(function(timelineSprite) {
                    stage.addChild(timelineSprite.sprite);
                });
            };

            loadStuff(sceneData)
                .load(function() {
                    const renderer = createRenderer();

                    const stage = new PIXI.Container();

                    const timelineSprites = sceneData2timelineSprites(sceneData);

                    attachSpritesToStage(timelineSprites, stage);

                    setupLoop(renderer, stage);

                    setupTimer(timelineSprites);
                });
        </script>
    </body>
</html>
