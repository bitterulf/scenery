<html>
    <head>
        <script src="https://aframe.io/releases/0.6.1/aframe.min.js"></script>
        <script src="https://rawgit.com/ngokevin/aframe-animation-component/master/dist/aframe-animation-component.min.js"></script>
        <script src="https://rawgit.com/protyze/aframe-curve-component/master/dist/aframe-curve-component.min.js"></script>
        <script src="https://rawgit.com/protyze/aframe-alongpath-component/master/dist/aframe-alongpath-component.min.js"></script>
        <script src="https://rawgit.com/ngokevin/kframe/master/components/template/dist/aframe-template-component.min.js"></script>
        <script src="https://rawgit.com/tizzle/aframe-sprite-component/master/dist/aframe-sprite-component.min.js"></script>
        <script src="https://rawgit.com/maxkrieger/aframe-draw-component/master/dist/aframe-draw-component.min.js"></script>
        <script src="https://rawgit.com/scenevr/htmltexture-component/master/dist/aframe-htmltexture-component.min.js"></script>
        <script src="https://rawgit.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
        <script>
            const calculateFight = function(attackingTroop, defendingTroop, losses) {
                const defenders = [];
                const attackers = [];

                for (let d = 0; d < defendingTroop.count; d++) {
                    defenders.push({
                        type: defendingTroop.type,
                        x: 1,
                        y: d - defendingTroop.count / 2
                    })
                }

                for (let a = 0; a < attackingTroop.count; a++) {
                    attackers.push({
                        type: attackingTroop.type,
                        x: -1,
                        y: a - attackingTroop.count / 2
                    })
                }

                let killedDefenders = 0;

                while (killedDefenders <= losses) {
                    const randomDefenderId = Math.floor(Math.random() * defenders.length);
                    if (!defenders[randomDefenderId].dead) {
                        defenders[randomDefenderId].dead = true;
                        killedDefenders++;
                    }
                }

                const primaryTargets = [];
                const secondaryTargets = [];

                defenders.forEach(function(defender, index) {
                    if (defender.dead) {
                        primaryTargets.push(index);
                        console.log(defender);
                    }
                    else if ((defenders[index - 1] && defenders[index - 1].dead) || (defenders[index + 1] && defenders[index + 1].dead)) {
                        secondaryTargets.push(index);
                    }
                });

                primaryTargets.forEach(function(primaryTarget) {
                    let selectedAttacker = -1;
                    let selectedAttackerDistance = 0;
                    attackers.forEach(function(attacker, attackerIndex) {
                        const distance = Math.abs(defenders[primaryTarget].y - attacker.y);
                        if (!attacker.target) {
                            if (selectedAttacker < 0 || distance < selectedAttackerDistance) {
                                selectedAttacker = attackerIndex;
                                selectedAttackerDistance = distance;
                            }
                        }
                    });

                    attackers[selectedAttacker].target = primaryTarget;
                });

                secondaryTargets.forEach(function(secondaryTarget) {
                    let selectedAttacker = -1;
                    let selectedAttackerDistance = 0;
                    attackers.forEach(function(attacker, attackerIndex) {
                        const distance = Math.abs(defenders[secondaryTarget].y - attacker.y);
                        if (!attacker.target) {
                            if (selectedAttacker < 0 || distance < selectedAttackerDistance) {
                                selectedAttacker = attackerIndex;
                                selectedAttackerDistance = distance;
                            }
                        }
                    });

                    if (selectedAttacker > 0) {
                        attackers[selectedAttacker].target = secondaryTarget;
                        console.log('selected secondary', selectedAttacker, secondaryTarget);
                    }
                });

                console.log(attackers, defenders);

                const figures = [];

                attackers.forEach(function(attacker) {
                    const defender = defenders[attacker.target];

                    const positionString = '<a-position timeline-data="0 '+attacker.y+' 0 '+attacker.x+'"></a-position>'
                    +'<a-position timeline-data="0.5 '+defender.y+' 0 '+defender.x+'"></a-position>'
                    +'<a-position timeline-data="1 '+defender.y+' 0 '+defender.x+'"></a-position>';

                    figures.push('<a-figure position="'+attacker.y+' 0 '+attacker.x+'">'+positionString+'</a-figure>');
                });

                defenders.forEach(function(defender) {
                    const positionString = '<a-position timeline-data="0 '+defender.y+' 0 '+defender.x+'"></a-position>'
                    +'<a-position timeline-data="0.5 '+defender.y+' 0 '+defender.x+'"></a-position>'
                    +'<a-position timeline-data="1 '+defender.y+' 0 '+(defender.x + 1) +'"></a-position>';

                    figures.push('<a-figure position="'+defender.y+' 0 '+defender.x+'">'+positionString+'</a-figure>');
                });

                return figures.join();
            }

            AFRAME.registerComponent('timeline', {
                schema: {
                    duration: {type: 'number', default: 1000},
                    steps: {type: 'number', default: 100}
                },
                init: function () {
                    const data = this.data;
                    const el = this.el;
                    let fraction = 0.001;

                    const positions = Array.prototype.slice.call(this.el.querySelectorAll('a-position')).map(function(el) {
                        return el.getAttribute('timeline-data').split(' ').map(parseFloat);
                    });

                    const positionV = positions.map(function(pos) {
                        const vec = new THREE.Vector3(pos[1], pos[2], pos[3]);
                        return vec;
                    });

                    const curve = new THREE.CatmullRomCurve3(
                        positionV
                    );

                    const steps = [];

                    for (let i = 0; i < 100; i++) {
                        const fraction = i / 100;
                        const position = curve.getPointAt(fraction);

                        steps.push({
                            step: i,
                            fraction: fraction,
                            position: position,
                        });
                    }

                    let nearestStep = 0;

                    positionV.forEach(function(originalPosition, positionIndex) {
                        if (positionIndex == positionV.length - 1) {
                            return;
                        }

                        steps.forEach(function(step, index) {
                            if (index > nearestStep) {
                                if (step.position.distanceTo(originalPosition) < steps[nearestStep].position.distanceTo(originalPosition)) {
                                    nearestStep = index;
                                }
                            }
                        });

                        steps[nearestStep].positionIndex = positionIndex;
                    });

                    let lastPositionIndex = 0;

                    steps.forEach(function(step, index) {
                        if (step.positionIndex) {
                            lastPositionIndex = step.positionIndex;
                        } else {
                            step.positionIndex = lastPositionIndex;
                        }
                    });

                    const positionGroups = {};

                    steps.forEach(function(step, index) {
                        if (!positionGroups[step.positionIndex]) {
                            positionGroups[step.positionIndex] = {
                                length: 0,
                                start: -1
                            };
                        }
                        if (positionGroups[step.positionIndex].start < 0) {
                            positionGroups[step.positionIndex].start = index;
                        }
                        else {
                            positionGroups[step.positionIndex].end = index;
                        }
                        positionGroups[step.positionIndex].length++;
                    });

                    steps.forEach(function(step, index) {
                        const positionGroup = positionGroups[step.positionIndex];
                        step.fraction =  (step.step - positionGroup.start) / positionGroup.length;
                    });

                    steps.forEach(function(step, index) {
                        step.timeA = positions[step.positionIndex][0];
                        step.timeB = positions[step.positionIndex + 1][0];
                        step.calulatedTime = (step.timeB - step.timeA) * step.fraction + step.timeA;
                    });

                    const calculatePosition = function(frameFraction) {
                        let lastStep = -1;

                        steps.forEach(function(step, index) {
                            if (step.calulatedTime > frameFraction && lastStep == -1) {
                                lastStep = index;
                            }
                        });

                        const stepA = steps[lastStep - 1];
                        const stepB = steps[lastStep];

                        if (lastStep < 0) {
                            return steps[0].position;
                        }

                        const timeTotalDistance = stepB.calulatedTime - stepA.calulatedTime;
                        const timePercent = (frameFraction - stepA.calulatedTime) / timeTotalDistance;
                        const cX = (stepB.position.x - stepA.position.x) * timePercent + stepA.position.x;
                        const cY = (stepB.position.y - stepA.position.y) * timePercent + stepA.position.y;
                        const cZ = (stepB.position.z - stepA.position.z) * timePercent + stepA.position.z;
                        const calcPosition = new THREE.Vector3(cX, cY, cZ);

                        return calcPosition;
                    };

                    el.addEventListener('timelineUpdate', function (ev) {
                        console.log('NICE!!!', ev.detail);
                        const pos = calculatePosition(ev.detail);
                        el.setAttribute('position', pos.x + ', ' + pos.y + ', ' + pos.z);
                    });
                }
            });

            AFRAME.registerComponent('figure', {
                init: function () {
                    const randomX = Math.random();
                    const randomY = Math.random();
                    const middle = Math.random()/5 + 0.2;
                    const height = Math.random()/5 + 0.2;

                    const end = (1 - middle) * Math.random() + middle;

                    const duration = Math.round(Math.random() * 500 + 500);
                    const steps = Math.round(duration / 1000 * 16);

                    this.el.innerHTML =
                    '<a-entity scale="0.22 0.22 0.22" timeline="duration: '+duration+'; steps: '+steps+'">'
                        +this.el.innerHTML
                        +'<a-entity position="0 4.42 0">'
                            +'<a-entity position="0 1.16 0" ply-model="src: url(upperBody.ply);">'
                                +'<a-entity position="0 1.850 0" ply-model="src: url(head.ply);"></a-entity>'
                                +'<a-entity position="-0.92 1.28 0" ply-model="src: url(upperArm.ply);">'
                                    +'<a-entity position="-0.25 -1.7 0" ply-model="src: url(lowerArm.ply);">'
                                        +'<a-entity position="0 -1.5 0" ply-model="src: url(hand.ply);"></a-entity>'
                                    +'</a-entity>'
                                +'</a-entity>'
                                +'<a-entity scale="1 1 1" position="0.92 1.28 0" ply-model="src: url(upperArm2.ply);">'
                                    +'<a-entity position="0.25 -1.7 0" ply-model="src: url(lowerArm2.ply);">'
                                        +'<a-entity position="0 -1.5 0" ply-model="src: url(hand2.ply);"></a-entity>'
                                    +'</a-entity>'
                                +'</a-entity>'
                                +'<a-entity position="-0.3 -1.4 0" ply-model="src: url(upperLeg.ply);">'
                                    +'<a-entity position="-0.2 -1.8 0" ply-model="src: url(lowerLeg.ply);">'
                                        +'<a-entity position="-0.1 -1.8 0" ply-model="src: url(foot.ply);"></a-entity>'
                                    +'</a-entity>'
                                +'</a-entity>'
                                +'<a-entity scale="1 1 1" position="0.3 -1.4 0" ply-model="src: url(upperLeg2.ply);">'
                                    +'<a-entity position="0.2 -1.8 0" ply-model="src: url(lowerLeg2.ply);">'
                                        +'<a-entity position="0.1 -1.8 0" ply-model="src: url(foot2.ply);"></a-entity>'
                                    +'</a-entity>'
                                +'</a-entity>'
                            +'</a-entity>'
                            +'<a-entity position="0 -0.10038 0" ply-model="src: url(lowerBody.ply);"></a-entity>'
                        +'</a-entity>'
                    +'</a-entity>';

                    const timelineElement = this.el.firstChild;

                    this.el.addEventListener('timelineUpdate', function (ev) {
                        timelineElement.dispatchEvent(new CustomEvent('timelineUpdate', ev));
                    });
                }
            });

            var extendDeep = AFRAME.utils.extendDeep;

            AFRAME.registerPrimitive('a-figure', extendDeep({}, AFRAME.primitives.getMeshMixin(), {
                defaultComponents: {
                    figure: ''
                }
            }));

            AFRAME.registerComponent('army', {
                init: function () {
                    const figures = [];

                    for (var y = 0; y < 5; y++) {
                        for (var x = 0; x < 10; x++) {

                            const randomX = Math.random();
                            const randomY = Math.random();
                            const middle = Math.random()/5 + 0.2;
                            const height = Math.random()/5 + 0.2;
                            const end = (1 - middle) * Math.random() + middle;

                            const positionString = '<a-position timeline-data="0 '+randomX+' 0 0"></a-position>'
                            +'<a-position timeline-data="'+middle+' '+randomX+' '+height+' '+randomY/2+'"></a-position>'
                            +'<a-position timeline-data="'+end+' '+randomX+' 0 '+randomY+'"></a-position>'
                            +'<a-position timeline-data="1 '+randomX+' 0 '+randomY+'"></a-position>';

                            figures.push('<a-figure position="'+y+' 0 '+x+'">'+positionString+'</a-figure>');
                        }
                    }

                    this.el.innerHTML = calculateFight({ type: 'swordsmen', count: 10 }, { type: 'peasant', count: 20 }, 5);

                    const figureNodes = this.el.querySelectorAll('a-figure');

                    const el = this.el;

                    this.el.addEventListener('timelineUpdate', function (ev) {
                        figureNodes.forEach(function(node) {
                            node.dispatchEvent(new CustomEvent('timelineUpdate', ev));
                        });
                    });
                }
            });

            AFRAME.registerPrimitive('a-army', extendDeep({}, AFRAME.primitives.getMeshMixin(), {
                defaultComponents: {
                    army: ''
                }
            }));

        </script>
    </head>
    <body>
        <div style="width: 512px; height: 512px;">
            <a-scene embedded="true" stats>

            <a-assets>
                <script id="head" type="html">
                    <a-entity position="0 1.850 0" ply-model="src: url(head.ply);"></a-entity>
                </script>
                <script id="body" type="html">
                    <a-entity position="0 1.16 0" ply-model="src: url(upperBody.ply);">
                </script>
            </a-assets>

                <a-entity camera look-controls wasd-controls="fly: true"></a-entity>

                <a-entity>
                    <a-army position="0 0 0"></a-army>
                </a-entity>
            </a-scene>
        </div>
        <script>
            const army = document.getElementsByTagName('a-army')[0];

            let timer = 0;

            window.setInterval(function() {
                timer += 0.01;

                if (timer > 1) {
                    timer -=1;
                }

                army.dispatchEvent(new CustomEvent('timelineUpdate', { detail: timer }));
            }, 10);
        </script>
    </body>
</html>
