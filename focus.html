<html>
    <head>
        <script src="https://aframe.io/releases/0.6.1/aframe.min.js"></script>
        <script src="https://rawgit.com/ngokevin/aframe-animation-component/master/dist/aframe-animation-component.min.js"></script>
        <script src="https://rawgit.com/protyze/aframe-curve-component/master/dist/aframe-curve-component.min.js"></script>
        <script src="https://rawgit.com/protyze/aframe-alongpath-component/master/dist/aframe-alongpath-component.min.js"></script>
        <script src="https://rawgit.com/ngokevin/kframe/master/components/template/dist/aframe-template-component.min.js"></script>
        <script src="https://rawgit.com/tizzle/aframe-sprite-component/master/dist/aframe-sprite-component.min.js"></script>
        <script src="https://rawgit.com/maxkrieger/aframe-draw-component/master/dist/aframe-draw-component.min.js"></script>
        <script src="https://rawgit.com/scenevr/htmltexture-component/master/dist/aframe-htmltexture-component.min.js"></script>
        <script src="https://rawgit.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
        <script>
            AFRAME.registerComponent('timeline', {
                schema: {
                    duration: {type: 'number', default: 1000},
                    steps: {type: 'number', default: 100}
                },
                init: function () {
                    const data = this.data;
                    const el = this.el;
                    let fraction = 0.001;

                    const positions = Array.prototype.slice.call(this.el.querySelectorAll('a-position')).map(function(el) {
                        return el.getAttribute('timeline-data').split(' ').map(parseFloat);
                    });

                    console.log('funky', positions);

                    const positionV = positions.map(function(pos) {
                        const vec = new THREE.Vector3(pos[1], pos[2], pos[3]);
                        return vec;
                    });

                    const curve = new THREE.CatmullRomCurve3(
                        positionV
                    );

                    const steps = [];

                    for (let i = 0; i < 100; i++) {
                        const fraction = i / 100;
                        const position = curve.getPointAt(fraction);

                        steps.push({
                            step: i,
                            fraction: fraction,
                            position: position,
                        });
                    }

                    let nearestStep = 0;

                    positionV.forEach(function(originalPosition, positionIndex) {
                        if (positionIndex == positionV.length - 1) {
                            return;
                        }

                        steps.forEach(function(step, index) {
                            if (index > nearestStep) {
                                if (step.position.distanceTo(originalPosition) < steps[nearestStep].position.distanceTo(originalPosition)) {
                                    nearestStep = index;
                                }
                            }
                        });

                        steps[nearestStep].positionIndex = positionIndex;
                        console.log('near', nearestStep);
                    });

                    let lastPositionIndex = 0;

                    steps.forEach(function(step, index) {
                        if (step.positionIndex) {
                            lastPositionIndex = step.positionIndex;
                        } else {
                            step.positionIndex = lastPositionIndex;
                        }
                    });

                    const positionGroups = {};

                    steps.forEach(function(step, index) {
                        if (!positionGroups[step.positionIndex]) {
                            positionGroups[step.positionIndex] = {
                                length: 0,
                                start: -1
                            };
                        }
                        if (positionGroups[step.positionIndex].start < 0) {
                            positionGroups[step.positionIndex].start = index;
                        }
                        else {
                            positionGroups[step.positionIndex].end = index;
                        }
                        positionGroups[step.positionIndex].length++;
                    });

                    steps.forEach(function(step, index) {
                        const positionGroup = positionGroups[step.positionIndex];
                        step.fraction =  (step.step - positionGroup.start) / positionGroup.length;
                    });

                    steps.forEach(function(step, index) {
                        step.timeA = positions[step.positionIndex][0];
                        step.timeB = positions[step.positionIndex + 1][0];
                        step.calulatedTime = (step.timeB - step.timeA) * step.fraction + step.timeA;
                    });

                    const calculatePosition = function(frameFraction) {
                        let lastStep = -1;

                        steps.forEach(function(step, index) {
                            if (step.calulatedTime > frameFraction && lastStep == -1) {
                                lastStep = index;
                            }
                        });

                        const stepA = steps[lastStep - 1];
                        const stepB = steps[lastStep];

                        if (lastStep < 0) {
                            return steps[0].position;
                        }

                        const timeTotalDistance = stepB.calulatedTime - stepA.calulatedTime;
                        const timePercent = (frameFraction - stepA.calulatedTime) / timeTotalDistance;
                        const cX = (stepB.position.x - stepA.position.x) * timePercent + stepA.position.x;
                        const cY = (stepB.position.y - stepA.position.y) * timePercent + stepA.position.y;
                        const cZ = (stepB.position.z - stepA.position.z) * timePercent + stepA.position.z;
                        const calcPosition = new THREE.Vector3(cX, cY, cZ);

                        return calcPosition;
                    };

                    el.addEventListener('timelineUpdate', function (ev) {
                        const pos = calculatePosition(ev.detail);
                        el.setAttribute('position', pos.x + ', ' + pos.y + ', ' + pos.z);
                    });

                    setInterval(function() {

                        el.emit('timelineUpdate', fraction);

                        fraction += 1 / data.steps;

                        if (fraction > 1) {
                            fraction -= 1;
                        }
                    }, data.duration / data.steps);
                }
            });
        </script>
    </head>
    <body>
        <div style="width: 512px; height: 512px;">
            <a-scene embedded="true">
                <a-entity>

                    <a-entity position="0 0 -3">
                        <a-entity position="0 1.16 0" ply-model="src: url(upperBody.ply);">
                            <a-entity position="0 1.850 0" ply-model="src: url(head.ply);"></a-entity>

                            <a-entity position="-0.92 1.28 0" ply-model="src: url(upperArm.ply);">
                                <a-entity position="-0.25 -1.7 0" ply-model="src: url(lowerArm.ply);">
                                    <a-entity position="0 -1.5 0" ply-model="src: url(hand.ply);"></a-entity>
                                </a-entity>
                            </a-entity>
                            <a-entity scale="1 1 1" position="0.92 1.28 0" ply-model="src: url(upperArm2.ply);">
                                <a-entity position="0.25 -1.7 0" ply-model="src: url(lowerArm2.ply);">
                                    <a-entity position="0 -1.5 0" ply-model="src: url(hand2.ply);"></a-entity>
                                </a-entity>
                            </a-entity>
                            <a-entity position="-0.3 -1.4 0" ply-model="src: url(upperLeg.ply);">
                                <a-entity position="-0.2 -1.8 0" ply-model="src: url(lowerLeg.ply);">
                                    <a-entity position="-0.1 -1.8 0" ply-model="src: url(foot.ply);"></a-entity>
                                </a-entity>
                            </a-entity>
                            <a-entity scale="1 1 1" position="0.3 -1.4 0" ply-model="src: url(upperLeg2.ply);">
                                <a-entity position="0.2 -1.8 0" ply-model="src: url(lowerLeg2.ply);">
                                    <a-entity position="0.1 -1.8 0" ply-model="src: url(foot2.ply);"></a-entity>
                                </a-entity>
                            </a-entity>
                        </a-entity>
                        <a-entity position="0 -0.10038 0" ply-model="src: url(lowerBody.ply);"></a-entity>
                    </a-entity>

                    <a-position timeline-data="0 0 0 0" />
                    <a-position timeline-data="0.01 1 0 0" />
                    <a-position timeline-data="0.02 1 1 1" />
                    <a-position timeline-data="0.03 0 1 0" />
                    <a-position timeline-data="1 0 0 0" />
                </a-entity>
            </a-scene>
        </div>
    </body>
</html>
